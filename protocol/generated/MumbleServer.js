//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `MumbleServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */
import * as IceNS from "ice";
const exportDict = {};
(function(module, require, exports)
{
    const Ice = require("ice").Ice;
    const _ModuleRegistry = Ice._ModuleRegistry;
    const Glacier2 = require("ice").Glacier2;
    const Slice = Ice.Slice;

    let MumbleServer = _ModuleRegistry.module("MumbleServer");

    Slice.defineSequence(MumbleServer, "NetAddressHelper", "Ice.ByteHelper", true);

    /**
     * A connected user.
     **/
    MumbleServer.User = class
    {
        constructor(session = 0, userid = 0, mute = false, deaf = false, suppress = false, prioritySpeaker = false, selfMute = false, selfDeaf = false, recording = false, channel = 0, name = "", onlinesecs = 0, bytespersec = 0, version = 0, version2 = new Ice.Long(0, 0), release = "", os = "", osversion = "", identity = "", context = "", comment = "", address = null, tcponly = false, idlesecs = 0, udpPing = 0.0, tcpPing = 0.0)
        {
            this.session = session;
            this.userid = userid;
            this.mute = mute;
            this.deaf = deaf;
            this.suppress = suppress;
            this.prioritySpeaker = prioritySpeaker;
            this.selfMute = selfMute;
            this.selfDeaf = selfDeaf;
            this.recording = recording;
            this.channel = channel;
            this.name = name;
            this.onlinesecs = onlinesecs;
            this.bytespersec = bytespersec;
            this.version = version;
            this.version2 = version2;
            this.release = release;
            this.os = os;
            this.osversion = osversion;
            this.identity = identity;
            this.context = context;
            this.comment = comment;
            this.address = address;
            this.tcponly = tcponly;
            this.idlesecs = idlesecs;
            this.udpPing = udpPing;
            this.tcpPing = tcpPing;
        }

        _write(ostr)
        {
            ostr.writeInt(this.session);
            ostr.writeInt(this.userid);
            ostr.writeBool(this.mute);
            ostr.writeBool(this.deaf);
            ostr.writeBool(this.suppress);
            ostr.writeBool(this.prioritySpeaker);
            ostr.writeBool(this.selfMute);
            ostr.writeBool(this.selfDeaf);
            ostr.writeBool(this.recording);
            ostr.writeInt(this.channel);
            ostr.writeString(this.name);
            ostr.writeInt(this.onlinesecs);
            ostr.writeInt(this.bytespersec);
            ostr.writeInt(this.version);
            ostr.writeLong(this.version2);
            ostr.writeString(this.release);
            ostr.writeString(this.os);
            ostr.writeString(this.osversion);
            ostr.writeString(this.identity);
            ostr.writeString(this.context);
            ostr.writeString(this.comment);
            MumbleServer.NetAddressHelper.write(ostr, this.address);
            ostr.writeBool(this.tcponly);
            ostr.writeInt(this.idlesecs);
            ostr.writeFloat(this.udpPing);
            ostr.writeFloat(this.tcpPing);
        }

        _read(istr)
        {
            this.session = istr.readInt();
            this.userid = istr.readInt();
            this.mute = istr.readBool();
            this.deaf = istr.readBool();
            this.suppress = istr.readBool();
            this.prioritySpeaker = istr.readBool();
            this.selfMute = istr.readBool();
            this.selfDeaf = istr.readBool();
            this.recording = istr.readBool();
            this.channel = istr.readInt();
            this.name = istr.readString();
            this.onlinesecs = istr.readInt();
            this.bytespersec = istr.readInt();
            this.version = istr.readInt();
            this.version2 = istr.readLong();
            this.release = istr.readString();
            this.os = istr.readString();
            this.osversion = istr.readString();
            this.identity = istr.readString();
            this.context = istr.readString();
            this.comment = istr.readString();
            this.address = MumbleServer.NetAddressHelper.read(istr);
            this.tcponly = istr.readBool();
            this.idlesecs = istr.readInt();
            this.udpPing = istr.readFloat();
            this.tcpPing = istr.readFloat();
        }

        static get minWireSize()
        {
            return  60;
        }
    };

    Slice.defineStruct(MumbleServer.User, false, true);

    Slice.defineSequence(MumbleServer, "IntListHelper", "Ice.IntHelper", true);

    /**
     * A text message between users.
     **/
    MumbleServer.TextMessage = class
    {
        constructor(sessions = null, channels = null, trees = null, text = "")
        {
            this.sessions = sessions;
            this.channels = channels;
            this.trees = trees;
            this.text = text;
        }

        _write(ostr)
        {
            MumbleServer.IntListHelper.write(ostr, this.sessions);
            MumbleServer.IntListHelper.write(ostr, this.channels);
            MumbleServer.IntListHelper.write(ostr, this.trees);
            ostr.writeString(this.text);
        }

        _read(istr)
        {
            this.sessions = MumbleServer.IntListHelper.read(istr);
            this.channels = MumbleServer.IntListHelper.read(istr);
            this.trees = MumbleServer.IntListHelper.read(istr);
            this.text = istr.readString();
        }

        static get minWireSize()
        {
            return  4;
        }
    };

    Slice.defineStruct(MumbleServer.TextMessage, true, true);

    /**
     * A channel.
     **/
    MumbleServer.Channel = class
    {
        constructor(id = 0, name = "", parent = 0, links = null, description = "", temporary = false, position = 0)
        {
            this.id = id;
            this.name = name;
            this.parent = parent;
            this.links = links;
            this.description = description;
            this.temporary = temporary;
            this.position = position;
        }

        _write(ostr)
        {
            ostr.writeInt(this.id);
            ostr.writeString(this.name);
            ostr.writeInt(this.parent);
            MumbleServer.IntListHelper.write(ostr, this.links);
            ostr.writeString(this.description);
            ostr.writeBool(this.temporary);
            ostr.writeInt(this.position);
        }

        _read(istr)
        {
            this.id = istr.readInt();
            this.name = istr.readString();
            this.parent = istr.readInt();
            this.links = MumbleServer.IntListHelper.read(istr);
            this.description = istr.readString();
            this.temporary = istr.readBool();
            this.position = istr.readInt();
        }

        static get minWireSize()
        {
            return  16;
        }
    };

    Slice.defineStruct(MumbleServer.Channel, true, true);

    /**
     * A group. Groups are defined per channel, and can inherit members from parent channels.
     **/
    MumbleServer.Group = class
    {
        constructor(name = "", inherited = false, inherit = false, inheritable = false, add = null, remove = null, members = null)
        {
            this.name = name;
            this.inherited = inherited;
            this.inherit = inherit;
            this.inheritable = inheritable;
            this.add = add;
            this.remove = remove;
            this.members = members;
        }

        _write(ostr)
        {
            ostr.writeString(this.name);
            ostr.writeBool(this.inherited);
            ostr.writeBool(this.inherit);
            ostr.writeBool(this.inheritable);
            MumbleServer.IntListHelper.write(ostr, this.add);
            MumbleServer.IntListHelper.write(ostr, this.remove);
            MumbleServer.IntListHelper.write(ostr, this.members);
        }

        _read(istr)
        {
            this.name = istr.readString();
            this.inherited = istr.readBool();
            this.inherit = istr.readBool();
            this.inheritable = istr.readBool();
            this.add = MumbleServer.IntListHelper.read(istr);
            this.remove = MumbleServer.IntListHelper.read(istr);
            this.members = MumbleServer.IntListHelper.read(istr);
        }

        static get minWireSize()
        {
            return  7;
        }
    };

    Slice.defineStruct(MumbleServer.Group, true, true);

    Object.defineProperty(MumbleServer, 'PermissionWrite', {
        value: 1
    });

    Object.defineProperty(MumbleServer, 'PermissionTraverse', {
        value: 2
    });

    Object.defineProperty(MumbleServer, 'PermissionEnter', {
        value: 4
    });

    Object.defineProperty(MumbleServer, 'PermissionSpeak', {
        value: 8
    });

    Object.defineProperty(MumbleServer, 'PermissionWhisper', {
        value: 256
    });

    Object.defineProperty(MumbleServer, 'PermissionMuteDeafen', {
        value: 16
    });

    Object.defineProperty(MumbleServer, 'PermissionMove', {
        value: 32
    });

    Object.defineProperty(MumbleServer, 'PermissionMakeChannel', {
        value: 64
    });

    Object.defineProperty(MumbleServer, 'PermissionMakeTempChannel', {
        value: 1024
    });

    Object.defineProperty(MumbleServer, 'PermissionLinkChannel', {
        value: 128
    });

    Object.defineProperty(MumbleServer, 'PermissionTextMessage', {
        value: 512
    });

    Object.defineProperty(MumbleServer, 'PermissionKick', {
        value: 65536
    });

    Object.defineProperty(MumbleServer, 'PermissionBan', {
        value: 131072
    });

    Object.defineProperty(MumbleServer, 'PermissionRegister', {
        value: 262144
    });

    Object.defineProperty(MumbleServer, 'PermissionRegisterSelf', {
        value: 524288
    });

    Object.defineProperty(MumbleServer, 'ResetUserContent', {
        value: 1048576
    });

    /**
     * Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.
     **/
    MumbleServer.ACL = class
    {
        constructor(applyHere = false, applySubs = false, inherited = false, userid = 0, group = "", allow = 0, deny = 0)
        {
            this.applyHere = applyHere;
            this.applySubs = applySubs;
            this.inherited = inherited;
            this.userid = userid;
            this.group = group;
            this.allow = allow;
            this.deny = deny;
        }

        _write(ostr)
        {
            ostr.writeBool(this.applyHere);
            ostr.writeBool(this.applySubs);
            ostr.writeBool(this.inherited);
            ostr.writeInt(this.userid);
            ostr.writeString(this.group);
            ostr.writeInt(this.allow);
            ostr.writeInt(this.deny);
        }

        _read(istr)
        {
            this.applyHere = istr.readBool();
            this.applySubs = istr.readBool();
            this.inherited = istr.readBool();
            this.userid = istr.readInt();
            this.group = istr.readString();
            this.allow = istr.readInt();
            this.deny = istr.readInt();
        }

        static get minWireSize()
        {
            return  16;
        }
    };

    Slice.defineStruct(MumbleServer.ACL, true, true);

    /**
     * A single ip mask for a ban.
     **/
    MumbleServer.Ban = class
    {
        constructor(address = null, bits = 0, name = "", hash = "", reason = "", start = 0, duration = 0)
        {
            this.address = address;
            this.bits = bits;
            this.name = name;
            this.hash = hash;
            this.reason = reason;
            this.start = start;
            this.duration = duration;
        }

        _write(ostr)
        {
            MumbleServer.NetAddressHelper.write(ostr, this.address);
            ostr.writeInt(this.bits);
            ostr.writeString(this.name);
            ostr.writeString(this.hash);
            ostr.writeString(this.reason);
            ostr.writeInt(this.start);
            ostr.writeInt(this.duration);
        }

        _read(istr)
        {
            this.address = MumbleServer.NetAddressHelper.read(istr);
            this.bits = istr.readInt();
            this.name = istr.readString();
            this.hash = istr.readString();
            this.reason = istr.readString();
            this.start = istr.readInt();
            this.duration = istr.readInt();
        }

        static get minWireSize()
        {
            return  16;
        }
    };

    Slice.defineStruct(MumbleServer.Ban, true, true);

    /**
     * A entry in the log.
     **/
    MumbleServer.LogEntry = class
    {
        constructor(timestamp = 0, txt = "")
        {
            this.timestamp = timestamp;
            this.txt = txt;
        }

        _write(ostr)
        {
            ostr.writeInt(this.timestamp);
            ostr.writeString(this.txt);
        }

        _read(istr)
        {
            this.timestamp = istr.readInt();
            this.txt = istr.readString();
        }

        static get minWireSize()
        {
            return  5;
        }
    };

    Slice.defineStruct(MumbleServer.LogEntry, true, true);

    Slice.defineSequence(MumbleServer, "TreeListHelper", "Ice.ObjectHelper", false, "MumbleServer.Tree");

    MumbleServer.ChannelInfo = Slice.defineEnum([
        ['ChannelDescription', 0], ['ChannelPosition', 1]]);

    MumbleServer.UserInfo = Slice.defineEnum([
        ['UserName', 0], ['UserEmail', 1], ['UserComment', 2], ['UserHash', 3], ['UserPassword', 4],
        ['UserLastActive', 5], ['UserKDFIterations', 6]]);

    Slice.defineDictionary(MumbleServer, "UserMap", "UserMapHelper", "Ice.IntHelper", "MumbleServer.User", false, undefined, undefined);

    Slice.defineDictionary(MumbleServer, "ChannelMap", "ChannelMapHelper", "Ice.IntHelper", "MumbleServer.Channel", false, undefined, undefined);

    Slice.defineSequence(MumbleServer, "ChannelListHelper", "MumbleServer.Channel", false);

    Slice.defineSequence(MumbleServer, "UserListHelper", "MumbleServer.User", false);

    Slice.defineSequence(MumbleServer, "GroupListHelper", "MumbleServer.Group", false);

    Slice.defineSequence(MumbleServer, "ACLListHelper", "MumbleServer.ACL", false);

    Slice.defineSequence(MumbleServer, "LogListHelper", "MumbleServer.LogEntry", false);

    Slice.defineSequence(MumbleServer, "BanListHelper", "MumbleServer.Ban", false);

    Slice.defineSequence(MumbleServer, "IdListHelper", "Ice.IntHelper", true);

    Slice.defineSequence(MumbleServer, "NameListHelper", "Ice.StringHelper", false);

    Slice.defineDictionary(MumbleServer, "NameMap", "NameMapHelper", "Ice.IntHelper", "Ice.StringHelper", false, undefined, undefined);

    Slice.defineDictionary(MumbleServer, "IdMap", "IdMapHelper", "Ice.StringHelper", "Ice.IntHelper", false, undefined, undefined);

    Slice.defineSequence(MumbleServer, "TextureHelper", "Ice.ByteHelper", true);

    Slice.defineDictionary(MumbleServer, "ConfigMap", "ConfigMapHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);

    Slice.defineSequence(MumbleServer, "GroupNameListHelper", "Ice.StringHelper", false);

    Slice.defineSequence(MumbleServer, "CertificateDerHelper", "Ice.ByteHelper", true);

    Slice.defineSequence(MumbleServer, "CertificateListHelper", "MumbleServer.CertificateDerHelper", false);

    Slice.defineDictionary(MumbleServer, "UserInfoMap", "UserInfoMapHelper", "MumbleServer.UserInfo._helper", "Ice.StringHelper", false, undefined, undefined);

    const iceC_MumbleServer_Tree_ids = [
        "::Ice::Object",
        "::MumbleServer::Tree"
    ];

    /**
     * User and subchannel state. Read-only.
     **/
    MumbleServer.Tree = class extends Ice.Value
    {
        constructor(c = new MumbleServer.Channel(), children = null, users = null)
        {
            super();
            this.c = c;
            this.children = children;
            this.users = users;
        }

        _iceWriteMemberImpl(ostr)
        {
            MumbleServer.Channel.write(ostr, this.c);
            MumbleServer.TreeListHelper.write(ostr, this.children);
            MumbleServer.UserListHelper.write(ostr, this.users);
        }

        _iceReadMemberImpl(istr)
        {
            this.c = MumbleServer.Channel.read(istr, this.c);
            this.children = MumbleServer.TreeListHelper.read(istr);
            this.users = MumbleServer.UserListHelper.read(istr);
        }
    };

    Slice.defineValue(MumbleServer.Tree, iceC_MumbleServer_Tree_ids[1], false);

    MumbleServer.MurmurException = class extends Ice.UserException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Ice.UserException;
        }

        static get _id()
        {
            return "::MumbleServer::MurmurException";
        }

        _mostDerivedType()
        {
            return MumbleServer.MurmurException;
        }
    };

    /**
     * This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to {@link Server.getUsers}. See {@link User.session}
     **/
    MumbleServer.InvalidSessionException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidSessionException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidSessionException;
        }
    };

    /**
     * This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.
     **/
    MumbleServer.InvalidChannelException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidChannelException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidChannelException;
        }
    };

    /**
     * This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.
     **/
    MumbleServer.InvalidServerException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidServerException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidServerException;
        }
    };

    /**
     * This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.
     **/
    MumbleServer.ServerBootedException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::ServerBootedException";
        }

        _mostDerivedType()
        {
            return MumbleServer.ServerBootedException;
        }
    };

    /**
     * This is thrown if {@link Server.start} fails, and should generally be the cause for some concern.
     **/
    MumbleServer.ServerFailureException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::ServerFailureException";
        }

        _mostDerivedType()
        {
            return MumbleServer.ServerFailureException;
        }
    };

    /**
     * This is thrown when you specify an invalid userid.
     **/
    MumbleServer.InvalidUserException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidUserException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidUserException;
        }
    };

    /**
     * This is thrown when you try to set an invalid texture.
     **/
    MumbleServer.InvalidTextureException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidTextureException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidTextureException;
        }
    };

    /**
     * This is thrown when you supply an invalid callback.
     **/
    MumbleServer.InvalidCallbackException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidCallbackException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidCallbackException;
        }
    };

    /**
     * This is thrown when you supply the wrong secret in the calling context.
     **/
    MumbleServer.InvalidSecretException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidSecretException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidSecretException;
        }
    };

    /**
     * This is thrown when the channel operation would exceed the channel nesting limit
     **/
    MumbleServer.NestingLimitException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::NestingLimitException";
        }

        _mostDerivedType()
        {
            return MumbleServer.NestingLimitException;
        }
    };

    /**
     * This is thrown when you ask the server to disclose something that should be secret.
     **/
    MumbleServer.WriteOnlyException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::WriteOnlyException";
        }

        _mostDerivedType()
        {
            return MumbleServer.WriteOnlyException;
        }
    };

    /**
     * This is thrown when invalid input data was specified.
     **/
    MumbleServer.InvalidInputDataException = class extends MumbleServer.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return MumbleServer.MurmurException;
        }

        static get _id()
        {
            return "::MumbleServer::InvalidInputDataException";
        }

        _mostDerivedType()
        {
            return MumbleServer.InvalidInputDataException;
        }
    };

    const iceC_MumbleServer_ServerCallback_ids = [
        "::Ice::Object",
        "::MumbleServer::ServerCallback"
    ];

    /**
     * Callback interface for servers. You can supply an implementation of this to receive notification
     * messages from the server.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     * Note that callbacks are removed when a server is stopped, so you should have a callback for
     * {@link MetaCallback.started} which calls {@link Server.addCallback}.
     * @see MetaCallback
     * @see Server.addCallback
     **/
    MumbleServer.ServerCallback = class extends Ice.Object
    {
    };

    MumbleServer.ServerCallbackPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(MumbleServer.ServerCallback, MumbleServer.ServerCallbackPrx, iceC_MumbleServer_ServerCallback_ids, 1,
    {
        "userConnected": [, 2, 2, , , [[MumbleServer.User]], , , , ],
        "userDisconnected": [, 2, 2, , , [[MumbleServer.User]], , , , ],
        "userStateChanged": [, 2, 2, , , [[MumbleServer.User]], , , , ],
        "userTextMessage": [, 2, 2, , , [[MumbleServer.User], [MumbleServer.TextMessage]], , , , ],
        "channelCreated": [, 2, 2, , , [[MumbleServer.Channel]], , , , ],
        "channelRemoved": [, 2, 2, , , [[MumbleServer.Channel]], , , , ],
        "channelStateChanged": [, 2, 2, , , [[MumbleServer.Channel]], , , , ]
    });

    Object.defineProperty(MumbleServer, 'ContextServer', {
        value: 1
    });

    Object.defineProperty(MumbleServer, 'ContextChannel', {
        value: 2
    });

    Object.defineProperty(MumbleServer, 'ContextUser', {
        value: 4
    });

    const iceC_MumbleServer_ServerContextCallback_ids = [
        "::Ice::Object",
        "::MumbleServer::ServerContextCallback"
    ];

    /**
     * Callback interface for context actions. You need to supply one of these for {@link Server.addContext}. 
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     **/
    MumbleServer.ServerContextCallback = class extends Ice.Object
    {
    };

    MumbleServer.ServerContextCallbackPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(MumbleServer.ServerContextCallback, MumbleServer.ServerContextCallbackPrx, iceC_MumbleServer_ServerContextCallback_ids, 1,
    {
        "contextAction": [, 2, 2, , , [[7], [MumbleServer.User], [3], [3]], , , , ]
    });

    const iceC_MumbleServer_ServerAuthenticator_ids = [
        "::Ice::Object",
        "::MumbleServer::ServerAuthenticator"
    ];

    /**
     * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
     * synchronously. If the response lags, the entire murmur server will lag.
     * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
     * deadlock the server.
     **/
    MumbleServer.ServerAuthenticator = class extends Ice.Object
    {
    };

    MumbleServer.ServerAuthenticatorPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(MumbleServer.ServerAuthenticator, MumbleServer.ServerAuthenticatorPrx, iceC_MumbleServer_ServerAuthenticator_ids, 1,
    {
        "authenticate": [, 2, 2, , [3], [[7], [7], ["MumbleServer.CertificateListHelper"], [7], [1]], [[7], ["MumbleServer.GroupNameListHelper"]], , , ],
        "getInfo": [, 2, 2, , [1], [[3]], [["MumbleServer.UserInfoMapHelper"]], , , ],
        "nameToId": [, 2, 2, , [3], [[7]], , , , ],
        "idToName": [, 2, 2, , [7], [[3]], , , , ],
        "idToTexture": [, 2, 2, , ["MumbleServer.TextureHelper"], [[3]], , , , ]
    });

    const iceC_MumbleServer_ServerUpdatingAuthenticator_ids = [
        "::Ice::Object",
        "::MumbleServer::ServerAuthenticator",
        "::MumbleServer::ServerUpdatingAuthenticator"
    ];

    /**
     * Callback interface for server authentication and registration. This allows you to support both authentication
     * and account updating.
     * You do not need to implement this if all you want is authentication, you only need this if other scripts
     * connected to the same server calls e.g. {@link Server.setTexture}.
     * Almost all of these methods support fall through, meaning murmur should continue the operation against its
     * own database.
     **/
    MumbleServer.ServerUpdatingAuthenticator = class extends Ice.Object
    {
        static get _iceImplements()
        {
            return [
                MumbleServer.ServerAuthenticator
            ];
        }
    };

    MumbleServer.ServerUpdatingAuthenticatorPrx = class extends Ice.ObjectPrx
    {
        static get _implements()
        {
            return [
                MumbleServer.ServerAuthenticatorPrx];
        }
    };

    Slice.defineOperations(MumbleServer.ServerUpdatingAuthenticator, MumbleServer.ServerUpdatingAuthenticatorPrx, iceC_MumbleServer_ServerUpdatingAuthenticator_ids, 2,
    {
        "registerUser": [, , , , [3], [["MumbleServer.UserInfoMapHelper"]], , , , ],
        "unregisterUser": [, , , , [3], [[3]], , , , ],
        "getRegisteredUsers": [, 2, 2, , ["MumbleServer.NameMapHelper"], [[7]], , , , ],
        "setInfo": [, 2, 2, , [3], [[3], ["MumbleServer.UserInfoMapHelper"]], , , , ],
        "setTexture": [, 2, 2, , [3], [[3], ["MumbleServer.TextureHelper"]], , , , ]
    });

    const iceC_MumbleServer_Server_ids = [
        "::Ice::Object",
        "::MumbleServer::Server"
    ];

    /**
     * Per-server interface. This includes all methods for configuring and altering
     * the state of a single virtual server. You can retrieve a pointer to this interface
     * from one of the methods in {@link Meta}.
     **/
    MumbleServer.Server = class extends Ice.Object
    {
    };

    MumbleServer.ServerPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(MumbleServer.Server, MumbleServer.ServerPrx, iceC_MumbleServer_Server_ids, 1,
    {
        "isRunning": [, 2, 2, , [1], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "start": [, , , , , , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException,
            MumbleServer.ServerFailureException
        ], , ],
        "stop": [, , , , , , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "delete": ["_delete", , , , , , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "id": [, 2, 2, , [3], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "addCallback": [, , , , , [["MumbleServer.ServerCallbackPrx"]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "removeCallback": [, , , , , [["MumbleServer.ServerCallbackPrx"]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "setAuthenticator": [, , , , , [["MumbleServer.ServerAuthenticatorPrx"]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getConf": [, 2, 2, , [7], [[7]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.WriteOnlyException
        ], , ],
        "getAllConf": [, 2, 2, , ["MumbleServer.ConfigMapHelper"], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "setConf": [, 2, 2, , , [[7], [7]], ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "setSuperuserPassword": [, 2, 2, , , [[7]], ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getLog": [, 2, 2, , ["MumbleServer.LogListHelper"], [[3], [3]], ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getLogLen": [, 2, 2, , [3], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getUsers": [, 2, 2, , ["MumbleServer.UserMapHelper"], , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getChannels": [, 2, 2, , ["MumbleServer.ChannelMapHelper"], , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getCertificateList": [, 2, 2, , ["MumbleServer.CertificateListHelper"], [[3]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "getTree": [, 2, 2, , ["MumbleServer.Tree", true], , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , true],
        "getBans": [, 2, 2, , ["MumbleServer.BanListHelper"], , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "setBans": [, 2, 2, , , [["MumbleServer.BanListHelper"]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "kickUser": [, , , , , [[3], [7]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "getState": [, 2, 2, , [MumbleServer.User], [[3]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "setState": [, 2, 2, , , [[MumbleServer.User]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "sendMessage": [, , , , , [[3], [7]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "hasPermission": [, , , , [1], [[3], [3], [3]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "effectivePermissions": [, 2, 2, , [3], [[3], [3]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "addContextCallback": [, , , , , [[3], [7], [7], ["MumbleServer.ServerContextCallbackPrx"], [3]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "removeContextCallback": [, , , , , [["MumbleServer.ServerContextCallbackPrx"]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getChannelState": [, 2, 2, , [MumbleServer.Channel], [[3]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "setChannelState": [, 2, 2, , , [[MumbleServer.Channel]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.NestingLimitException,
            MumbleServer.ServerBootedException
        ], , ],
        "removeChannel": [, , , , , [[3]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "addChannel": [, , , , [3], [[7], [3]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.NestingLimitException,
            MumbleServer.ServerBootedException
        ], , ],
        "sendMessageChannel": [, , , , , [[3], [1], [7]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getACL": [, 2, 2, , , [[3]], [["MumbleServer.ACLListHelper"], ["MumbleServer.GroupListHelper"], [1]],
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "setACL": [, 2, 2, , , [[3], ["MumbleServer.ACLListHelper"], ["MumbleServer.GroupListHelper"], [1]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "addUserToGroup": [, 2, 2, , , [[3], [3], [7]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "removeUserFromGroup": [, 2, 2, , , [[3], [3], [7]], ,
        [
            MumbleServer.InvalidChannelException,
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "redirectWhisperGroup": [, 2, 2, , , [[3], [7], [7]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidSessionException,
            MumbleServer.ServerBootedException
        ], , ],
        "getUserNames": [, 2, 2, , ["MumbleServer.NameMapHelper"], [["MumbleServer.IdListHelper"]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getUserIds": [, 2, 2, , ["MumbleServer.IdMapHelper"], [["MumbleServer.NameListHelper"]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "registerUser": [, , , , [3], [["MumbleServer.UserInfoMapHelper"]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidUserException,
            MumbleServer.ServerBootedException
        ], , ],
        "unregisterUser": [, , , , , [[3]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidUserException,
            MumbleServer.ServerBootedException
        ], , ],
        "updateRegistration": [, 2, 2, , , [[3], ["MumbleServer.UserInfoMapHelper"]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidUserException,
            MumbleServer.ServerBootedException
        ], , ],
        "getRegistration": [, 2, 2, , ["MumbleServer.UserInfoMapHelper"], [[3]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidUserException,
            MumbleServer.ServerBootedException
        ], , ],
        "getRegisteredUsers": [, 2, 2, , ["MumbleServer.NameMapHelper"], [[7]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "verifyPassword": [, 2, 2, , [3], [[7], [7]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "getTexture": [, 2, 2, , ["MumbleServer.TextureHelper"], [[3]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidUserException,
            MumbleServer.ServerBootedException
        ], , ],
        "setTexture": [, 2, 2, , , [[3], ["MumbleServer.TextureHelper"]], ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.InvalidTextureException,
            MumbleServer.InvalidUserException,
            MumbleServer.ServerBootedException
        ], , ],
        "getUptime": [, 2, 2, , [3], , ,
        [
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "updateCertificate": [, 2, 2, , , [[7], [7], [7]], ,
        [
            MumbleServer.InvalidInputDataException,
            MumbleServer.InvalidSecretException,
            MumbleServer.ServerBootedException
        ], , ],
        "startListening": [, 2, 2, , , [[3], [3]], , , , ],
        "stopListening": [, 2, 2, , , [[3], [3]], , , , ],
        "isListening": [, 2, 2, , [1], [[3], [3]], , , , ],
        "getListeningChannels": [, 2, 2, , ["MumbleServer.IntListHelper"], [[3]], , , , ],
        "getListeningUsers": [, 2, 2, , ["MumbleServer.IntListHelper"], [[3]], , , , ],
        "getListenerVolumeAdjustment": [, 2, 2, , [5], [[3], [3]], , , , ],
        "setListenerVolumeAdjustment": [, 2, 2, , , [[3], [3], [5]], , , , ],
        "sendWelcomeMessage": [, 2, 2, , , [["MumbleServer.IdListHelper"]], , , , ]
    });

    const iceC_MumbleServer_MetaCallback_ids = [
        "::Ice::Object",
        "::MumbleServer::MetaCallback"
    ];

    /**
     * Callback interface for Meta. You can supply an implementation of this to receive notifications
     * when servers are stopped or started.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     * @see ServerCallback
     * @see Meta.addCallback
     **/
    MumbleServer.MetaCallback = class extends Ice.Object
    {
    };

    MumbleServer.MetaCallbackPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(MumbleServer.MetaCallback, MumbleServer.MetaCallbackPrx, iceC_MumbleServer_MetaCallback_ids, 1,
    {
        "started": [, , , , , [["MumbleServer.ServerPrx"]], , , , ],
        "stopped": [, , , , , [["MumbleServer.ServerPrx"]], , , , ]
    });

    Slice.defineSequence(MumbleServer, "ServerListHelper", "MumbleServer.ServerPrx", false);

    const iceC_MumbleServer_Meta_ids = [
        "::Ice::Object",
        "::MumbleServer::Meta"
    ];

    /**
     * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
     **/
    MumbleServer.Meta = class extends Ice.Object
    {
    };

    MumbleServer.MetaPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(MumbleServer.Meta, MumbleServer.MetaPrx, iceC_MumbleServer_Meta_ids, 1,
    {
        "getServer": [, 2, 2, , ["MumbleServer.ServerPrx"], [[3]], ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "newServer": [, , , , ["MumbleServer.ServerPrx"], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getBootedServers": [, 2, 2, , ["MumbleServer.ServerListHelper"], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getAllServers": [, 2, 2, , ["MumbleServer.ServerListHelper"], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getDefaultConf": [, 2, 2, , ["MumbleServer.ConfigMapHelper"], , ,
        [
            MumbleServer.InvalidSecretException
        ], , ],
        "getVersion": [, 2, 2, , , , [[3], [3], [3], [7]], , , ],
        "addCallback": [, , , , , [["MumbleServer.MetaCallbackPrx"]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException
        ], , ],
        "removeCallback": [, , , , , [["MumbleServer.MetaCallbackPrx"]], ,
        [
            MumbleServer.InvalidCallbackException,
            MumbleServer.InvalidSecretException
        ], , ],
        "getUptime": [, 2, 2, , [3], , , , , ],
        "getSlice": [, 2, 2, , [7], , , , , ],
        "getSliceChecksums": [, 2, 2, , ["Ice.SliceChecksumDictHelper"], , , , , ]
    });
    exports.MumbleServer = MumbleServer;
}
(undefined, (s)=>{
    if(s==="ice"){
        return IceNS;
    }else{
        throw new Error("Ice not available");
    }
}, exportDict));
export const MumbleServer = exportDict.MumbleServer;